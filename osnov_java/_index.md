---
order: 1
title: Основы java (Вводная)
---

-  [1\. Ключевые концепции и синтаксис](./klyuchevye-koncepcii-i-sintaxis)

-  [2\. Модификаторы доступа](./obektno-orientirovannoe-programmirovani)

-  [3\. Типы данных и переменные](./tipy-dannykh-i-peremennye/_index)

-  [4\. Циклы, операторы, выражения](./3-cikly-operatory-vyrazheniya/_index)

-  [5\. Исключения](./5-isklyucheniya)

## Основные правила синтаксиса Java

Есть несколько основных правил синтаксиса, которым нужно следовать при программировании на Java:

-  **В Java все находится(сродержится) в классах. Класс служит шаблоном для создания объектов.**

-  Чаще всего каждый класс находится в отдельном файле с расширением `.java `(**MyFirstJavaClass.java**). Имя файла должно совпадать с именем класса. Файлы классов обычно сгруппированы в папки. Эти папки называются **пакетами**;

-  Первая буква имени класса должна быть в верхнем регистре. Если вы используете несколько слов, указывайте прописные буквы для первой буквы каждого слова (например, «**M**y**F**irst**J**ava**C**lass»);

-  **Методы -- это** **функции, объявленные в классах**, представляет собой последовательность команд. Методы определяют поведение над объектом; Главный метод `main` служит точкой входа в программу: `public static void main (String [] args)`. Метод `main()` является обязательной частью любой Java-программы;

-  **Имена всех методов в синтаксисе Java начинаются со строчной буквы** (маленькой). При использовании нескольких слов последующие буквы пишутся заглавными (public void **m**y**F**irst**M**ethod**N**ame ());

-  Символы чувствительны к регистру. **String не равно string**;

-  Порядок методов в файле программы не имеет значения;

-  Каждый оператор кода должен заканчиваться точкой с запятой.

## Ключевые концепции Java

### 1\. Платформонезависимость

Java был разработан с целью обеспечения платформонезависимости. Благодаря Java Virtual Machine (JVM), код, написанный на Java, **может выполняться на любой платформе, где установлена JVM.**

Это достигается благодаря следующим механизмам и концепциям:

**\- Байт-код Java**: когда вы компилируете программу на Java, исходный код (.java файлы) компилируется не в машинный код для конкретной платформы, а в специальный формат, называемый байт-кодом Java (**.class файлы**).

![](./osnov_java.png)

### **Java SE (Java Standard Edition)**

**Java SE (Java Standard Edition)** -- это стандартное издание платформы Java, которое предоставляет базовую инфраструктуру для разработки и запуска Java-приложений на настольных компьютерах, серверах и аналогичных устройствах. Java SE включает в себя:

-  **Ядро Java API**: Базовый набор библиотек, необходимый для создания Java-приложений, включая коллекции, ввод-вывод, сетевые операции, многопоточность и многие другие.

-  **JVM (Java Virtual Machine)**: Виртуальная машина, которая интерпретирует и выполняет байт-код Java, обеспечивая платформенную независимость Java-приложений.

-  **Java Language Specification**: Документация, которая описывает формальные правила и структуры языка программирования Java.

-  **Другие инструменты и утилиты**: Набор инструментов для разработки, компиляции, отладки и мониторинга Java-приложений (частью этого набора является JDK -- Java Development Kit).

[html:iframe]

<hr/>

[/html]

### \_\_ JDK

Инструменты разработчика,  Java Development Kit (**JDK**) - представляет собой комплексное средство для разработки на языке Java. Основные компоненты и инструменты, входящие в состав JDK, включают ⇩:

![](./osnov_java-2.png)

### **\_\_ JRE**

**Java Runtime Environment** **(JRE)**: Это среда выполнения, в которой работают Java-приложения. Она включает в себя JVM и стандартную библиотеку классов Java. JRE доступна для многих операционных систем, включая Windows, Linux и macOS.

Это набор инструментов и библиотек, необходимых для запуска и выполнения Java-программ. JRE создана для обеспечения выполнения Java-приложений на различных платформах и устройствах без необходимости повторной компиляции кода.

Стоит отметить, что **JRE** предназначена только для запуска Java-приложений. Для разработки и компиляции Java-приложений требуется **JDK** (Java Development Kit).

### **\_\_ JVM**

**Java Virtual Machine (JVM)**: это виртуальную машина, способная интерпретировать и выполнять байт-код Java. Различные операционные системы имеют свои собственные версии JVM, что позволяет Java-приложениям работать на различных платформах без изменений. Когда вы запускаете Java-приложение, JVM читает и интерпретирует байт-код для выполнения на конкретной машине.

**JVM** -- это ключевая часть Java-платформы, которая отвечает за выполнение программ, написанных на Java. Работу JVM можно разделить на несколько этапов: от компиляции исходного кода до выполнения программы.

:::note:true **Реализации JVM  (подробнее…)**

**JVM** (**Java Virtual Machine**) имеет множество реализаций, созданных различными компаниями и организациями для разных нужд и платформ. Вот некоторые из наиболее известных реализаций JVM:



**HotSpot**: Это самая популярная реализация JVM, созданная компанией Sun Microsystems, которая впоследствии была приобретена Oracle. Она широко используется и является стандартной JVM в OpenJDK и Oracle JDK.

**JRockit**: Это высокопроизводительная реализация JVM, первоначально разработанная компанией Appeal, затем приобретенная BEA Systems, а в конечном итоге Oracle.

**OpenJ9**: Это открытая реализация JVM, созданная IBM. Она ранее была известна как J9 и широко используется в продуктах IBM.

**GraalVM**: Это высокопроизводительная полиморфная виртуальная машина, разработанная Oracle. Она включает в себя JIT-компилятор и может выполнять приложения, написанные на многих языках, включая Java, JavaScript, Ruby и других.

**Dalvik и ART (Android Runtime)**: Dalvik -- это реализация JVM, созданная специально для Android. С версии Android 5.0 (Lollipop) Dalvik был заменен на ART.

**Azul Zing**: Это коммерческая реализация JVM, разработанная Azul Systems. Она известна своей способностью предоставлять низкую задержку и высокую пропускную способность.

**Cacao**: Это открытая реализация JVM, которая может использовать JIT-компиляцию для улучшения производительности.

**JamVM**: Это легкая реализация JVM, написанная на C, и она может быть использована вместе с GNU Classpath.



Каждая из этих реализаций JVM предоставляет свои уникальные особенности и оптимизации, но все они способны исполнять байт-код Java, что обеспечивает платформенную независимость программ на Java.

:::

#### Основные этапы работы JVM:

1. **Компиляция исходного кода (**`.java`) в байт-код (`.class`):

   -  Исходный код, написанный на Java, сохраняется в файлах с расширением `.java`.

   -  **Java-компилятор** (обычно `javac`) компилирует исходный код в промежуточный код -- **байт-код**, который сохраняется в `.class` файлах.

   -  Байт-код не зависит от конкретной платформы (Windows, Mac, Linux и т.д.), и именно его JVM будет выполнять.

      ![](./osnov_java-3.png)

      Этот процесс создает файл `MyProgram.class`, содержащий байт-код.

2. **Загрузка байт-кода в JVM**:

   -  JVM загружает скомпилированные `.class` файлы в память.

   -  Это делается через [comment:9nwGz]**Class Loader**[/comment] -- механизм, который управляет загрузкой классов, включая их иерархию.

3. **Проверка байт-кода (Bytecode Verification)**:

   -  Прежде чем начать выполнение байт-кода, JVM проверяет его на наличие ошибок и корректность (например, чтобы предотвратить доступ к неразрешенным областям памяти или некорректные преобразования типов).

   -  Этот шаг обеспечивает безопасность и надежность выполнения кода.

4. **Интерпретация или компиляция байт-кода (JIT-компиляция)**:

   -  На этом этапе JVM начинает интерпретацию байт-кода и его выполнение. Каждый байт-код переводится в машинные инструкции для конкретной платформы.

   -  Однако для повышения производительности JVM использует **JIT-компилятор** (**Just-In-Time компиляция**), который компилирует часто исполняемый байт-код в **машинный код** (специфичный для вашей платформы), во время выполнения программы, что улучшает производительность.

5. **Управление памятью и сборка мусора (Garbage Collection)**:

   -  JVM управляет памятью программы через **кучу (heap)**, в которой создаются объекты.

   -  Для удаления ненужных объектов, которые больше не используются, JVM запускает процесс **сборки мусора (Garbage Collection)**. Это помогает освобождать память и предотвращать утечки.

6. **Выполнение программы**:

   -  После загрузки и компиляции байт-кода программа начинает выполняться.

   -  JVM управляет процессом выполнения программы, управляет потоками и синхронизацией, а также предоставляет средства обработки исключений.

7. **Завершение работы**:

   -  После завершения работы программы JVM очищает всю использованную память, закрывает потоки и завершает свое выполнение.

#### Основные компоненты JVM:

-  **Class Loader**: загружает классы в память.

-  **Bytecode Verifier**: проверяет корректность байт-кода.

-  **Execution Engine**: интерпретирует байт-код или компилирует его с помощью JIT.

-  **Garbage Collector**: управляет памятью и удаляет неиспользуемые объекты.

#### Схема работы JVM:

1. **Компиляция (javac)** --> 2. **Байт-код (.class)** --> 3. **Class Loader** --> 4. **Bytecode Verifier** --> 5. **JIT-компиляция/интерпретация** --> 6. **Выполнение программы** --> 7. **Сборка мусора и завершение**.



-  [comment:Kn4q2]**Стандарты и спецификации**[/comment]**:** Java имеет строгие стандарты и спецификации, определяющие, как должны работать JVM и стандартная библиотека. Это обеспечивает согласованное поведение на разных платформах.

-  [comment:Vdnuk]**Динамическая компиляция и оптимизация**[/comment]**:** Виртуальная машина Java может выполнять динамическую компиляцию и оптимизацию байт-кода в машинный код во время выполнения программы. Это позволяет адаптировать приложение к конкретной платформе и улучшить его производительность.

-  [comment:mKqAk]**Стандартная библиотека (API Java)**[/comment]**:** Java поставляется со стандартной библиотекой, которая предоставляет функции для выполнения различных задач, таких как работа с файлами, сетевое взаимодействие и графика. Благодаря этому разработчики могут использовать один и тот же код для доступа к ресурсам и сервисам, независимо от платформы. (API полунезависимо), что позволяет разработчикам использовать один и тот же код на разных платформах.

**Заключение:** Платформа независимость Java значительно упрощает разработку и развертывание программного обеспечения для разных систем. Однако стоит помнить, что, несмотря на платформа независимость языка, существуют ситуации, когда приложение может вести себя по-разному на разных системах из-за различий в реализации JVM или из-за специфичных для платформы особенностей.

### 2\. Объектно-Ориентированное Программирование (ООП)

Java является объектно-ориентированным языком программирования. Основные принципы ООП:

:::info:true 1) Инкапсуляция: Сокрытие внутренних деталей реализации.

**Инкапсуляция** -- это процесс сокрытия внутренних деталей реализации объекта и предоставления внешнему миру только необходимых методов для взаимодействия с объектом. Это помогает упростить код, предотвращает нежелательное изменение состояния объекта и улучшает безопасность.

В Java инкапсуляция достигается с помощью модификаторов доступа и методов доступа **(геттеров и сеттеров**). Модификаторы доступа определяют видимость переменной или метода:

`private`: доступен только внутри класса

`default` (*отсутствие модификатора*): доступен внутри пакета

`protected`: доступен внутри пакета и для наследников класса

`public`: доступен отовсюду

В общем то, пакеты классы, вложенные классы и методы тоже инкапсулируют код, и регулируют доступность из любой другой области программы

Таким образом в ООП инкапсуляция – это неотъемлемая сущность



**Рассмотрим пример с модификатором доступа**

Ну, вот мы защитили переменную:

`private char ch = 102;`

Но ее же надо как-то менять...

Влиять на прямую небезопасно и в другой области программы (например – классе) не получится уже, так как поле “ **private** ”.

Как менять данное поле(переменную) ?

⁠

Для этого существуют специальные методы - так называемые Геттеры и Сеттеры. Ну, они не то чтобы специальные - просто настолько часто используются, что были вынесены в отдельную категорию методов.

```java
private char ch = 102; 
public char getCh() {
    return ch;
}
public void setCh(char ch) {    
	this.ch = ch;
}
```

Сами методы `public`, а значит получить к ним доступ возможно из любой области программы. Таким образом мы сами задаем сценарий работы с данным полем.

:::

:::info:true 2) Наследование: Создание нового класса на основе существующего.

Одним из ключевых аспектов объектно-ориентированного программирования **является наследование**.

С помощью наследования можно расширить функционал уже имеющихся классов за счет добавления нового функционала или изменения старого.

Наследование (англ. inheritance) - это механизм, позволяющий создавать классы на основе другого класса.

Для того, чтобы унаследовать класс, нужно использовать ключевое слово **extends**:

```java
class Dog {
    void soung() { }
}
 
class Dobermann extends Dog {
	@Override // аннотация
	void soung() {
		System.out.println("Gav");
	}
}
```

## **Правила наследования**

**Правило 1. Наследуем только один класс.**

Java не поддерживает наследование нескольких классов. (нескольких можно только интерфейсов)

[html:iframe]

<mark style="background-color: transparent; color: #2F1704; font-family: 'Courier New', Courier, monospace; font-weight: bold; font-size: 18px;"> &nbsp - Один класс - один родитель.</mark><br/>
<mark style="background-color: transparent; color: #2F1704; font-family: 'Courier New', Courier, monospace; font-weight: bold; font-size: 18px;"> &nbsp - Обратите внимание - нельзя наследовать самого себя!</mark>

[/html]

**Правило 2. Наследуется все кроме приватных переменных и приватных методов.**

**Правило 3. Переопределение**

Методы абстрактных классов, и интерфейсов, **обязательно нужно переопределить** в классе наследнике, кроме тех что `defolt` (имеют реализацию)

Для этого в классе наследнике перед переопределяемым методом ставится аннотация `@Override`:

**(см. пример выше)**

**Методы обычного класса родителя (не абстрактного)** можно как переопределять так и не переопределять

**Правило 4. Вызываем методы (конструктора) родителя, через ключевое слово** `super`**. (Расширяем)**

```java
class Parent {
   void display() {
        System.out.println("Display in Parent");
    }
}
 
class Child extends Parent {
    void display() {
        super.display();  
// вызов метода display из родительского класса
        System.out.println("Display in Child");
    }
}
```

**Правило 5. Запрещаем наследование.**

Если Вы не хотите, чтобы кто-то наследовал Ваш класс, поставьте перед ним модификатор **final**.

:::

:::info:true 3) Полиморфизм: Один и тот же метод может работать разными способами в зависимости от контекста.

**Полиморфизм** в Java -- это одна из ключевых концепций объектно-ориентированного программирования (ООП), которая позволяет объектам разных классов обрабатывать методы с одинаковым именем по-разному, основываясь на их типах. Полиморфизм позволяет объекту иметь множество форм, что повышает гибкость и повторное использование кода.

(*Простыми словами*) **Полиморфизм** -- это возможность применения одноименных методов с одинаковыми или различными наборами параметров в одном классе или в группе классов, связанных отношением наследования.

## Виды полиморфизма:

### 1\. Перегрузка методов (***полиморфизм на уровне компиляции***)

{% table %}

---

*  {% colwidth=[25] %}

   

*  {% colwidth=[688] %}

   Перегрузка методов(Method Over**loading**) происходит, когда в одном классе определяется два или более метода `с одинаковым именем, но с разными параметрами`.

---

*  {% colwidth=[25] %}

   

*  {% colwidth=[688] %}

   **Цель:** Целью перегрузки методов является предоставление различных вариантов вызова метода для разных типов данных или аргументов, для обработки разных ситуации с разными аргументами.

{% /table %}

Называть методы одинаково - это очень удобно. Например, если у нас есть метод, который ищет корень квадратный из числа, гораздо легче запомнить одно название (например, `sqrt()`, чем по одному отдельному названию на этот же метод, написанный для каждого типа:

[image:./osnov_java-5.png::Пример <Перегрузки методов>:0:27:]

```yaml
Один интерфейс - много методов
```

То, что мы показывали выше - **несколько методов с одним названием и разными параметрами** - называется `перегрузкой`.

Рассмотрим `переопределение методов` - это **задание собственной реализации в классе наследника методам** которые были определены в супер классе(классе родителя).

### 2\. Переопределение методов (***Полиморфизм на уровне выполнения***)

{% table %}

---

*  {% colwidth=[25] %}

   

*  {% colwidth=[681] %}

   Переопределение метода (Method Over**riding**) происходит, когда **подкласс** предоставляет свою собственную реализацию метода, который уже определён в его **родительском классе**.

---

*  {% colwidth=[25] %}

   

*  {% colwidth=[681] %}

   Переопределённый метод в подклассе должен иметь то же имя, тип возвращаемого значения и параметры, что и метод в родительском классе. `Это позволяет подклассу изменять или расширять поведение метода, унаследованного от родителя.`

---

*  {% colwidth=[25] %}

   

*  {% colwidth=[681] %}

   ***Пример (переопределения метода)):***

   Когда мы наследуем какой-либо класс, мы наследуем и все его методы. Но если нам хочется изменить какой-либо из методов, который мы наследуем, мы можем всего-навсего переопределить его. А именно создать в классе наследника метод с той же сигнатурой(возвращаемым типом, с теми же аргументами и именем), задав этому методу свою реализацию

{% /table %}

Представим, что у нас есть такая структура:

[image:./osnov_java-7.png:::0,0,100,100:90:]

Вверху иерархии классов стоит класс **Animal**. Его наследуют три класса - **Cat**, **Dog** и **Cow**.

У класса «Animal» есть метод «голос» (`voice`). Этот метод выводит на экран сообщение "Голос". Естественно, ни собака, ни кошка не говорят. Они гавкают и мяукают. Соответственно, Вам нужно задать другой метод для классов **Cat**, **Dog** и **Cow** - чтобы кошка мяукала, собака гавкала, а корова говорила "Муу".

Поэтому, в классах-наследниках мы переопределяем метод **voice()**, чтобы мы в консоли получали "Мяу", "Гав" и "Муу".

## Заключение

Полиморфизм в Java позволяет одному и тому же методу работать с разными типами данных, будь то через перегрузку методов (компиляция) или переопределение методов (выполнение). Это делает код более гибким, расширяемым и легко поддерживаемым, что является одной из важнейших практик объектно-ориентированного программирования.

-  Создать "одноименные методы" в одном классе, с разным набором параметров - “`значит перегрузить методы`”

-  Изменить поведение метода родительского класса, в дочернем классе - “`значит переопределить метод`”

:::

:::info:true Подробнее

**Абстракция** в программировании -- это процесс отображения только необходимых и релевантных деталей, скрывая сложные и ненужные, предоставляя пользователю только необходимую функциональность. В Java абстракция в **основном реализуется с помощью абстрактных классов и интерфейсов**.



Что такое абстракция?

Абстракция позволяет сосредоточиться на высокоуровневых операциях, игнорируя низкоуровневые детали.



Как абстракция реализуется в Java?

Абстракция в Java реализуется с помощью абстрактных классов и интерфейсов. Абстракция позволяет скрыть детали реализации и предоставить только необходимый интерфейс или сущность для работы с объектами. Вот как это делается:



**Абстрактные классы:** Абстрактный класс в Java - это класс, который не может быть инстанциирован (т.е., создан объект этого класса), но может содержать абстрактные методы и конкретные методы. Абстрактный метод - это метод, который объявлен, но не имеет реализации в самом абстрактном классе. Дочерние классы, наследующие абстрактный класс, должны предоставить реализацию для всех абстрактных методов..

//////////

**Интерфейсы:** Интерфейс в Java - это абстрактный тип, который может содержать только абстрактные методы и константы (поля с ключевым словом final и static). Классы могут реализовывать интерфейсы, предоставляя реализацию для всех методов, объявленных в интерфейсе. Один класс может реализовывать несколько интерфейсов.

//////////

:::



**Абстракция**: Определение основных характеристик объекта, игнорируя не релевантные детали. 

```java
public abstract class Animal {
 public abstract void sound();
}
 
public class Dog extends Animal {
  @Override
  public void sound() {
   System.out.println("f");
    }
}
```

/

```java
public interface Eater {
    void eat();
}
 
public class Human implements Eater {
 @Override
 public void eat() {
  System.out.print("Man eat");
    }
}
```

(Подробнее мы разберем эти темы в след. главах, тогда станут они более понятны)




