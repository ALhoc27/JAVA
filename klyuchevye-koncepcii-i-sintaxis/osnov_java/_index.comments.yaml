9nwGz:
  comment:
    user:
      mail: alexbbtsk@gmail.com
      name: ALhoc27
    dateTime: '2024-10-06T15:00:51.227Z'
    content: >-
      JVM отвечает за загрузку классов и ресурсов в память во время выполнения.
      Класслоадеры обеспечивают изоляцию классов и гарантируют, что классы могут
      быть загружены по мере необходимости.
  answers: []
Vdnuk:
  comment:
    user:
      mail: alexbbtsk@gmail.com
      name: ALhoc27
    dateTime: '2024-10-06T15:15:45.103Z'
    content: >-
      Вот как динамическая компиляция и оптимизация могут адаптировать
      приложение к конкретной платформе и улучшить его производительность:




      **Адаптивная оптимизация**: Поскольку компиляция происходит во время
      выполнения, JVM может собирать информацию о том, какие части кода наиболее
      часто используются (горячие точки), и оптимизировать их для максимальной
      производительности.


      **Специфичные для платформы оптимизации**: При динамической компиляции JVM
      может учитывать особенности конкретной архитектуры процессора и системы в
      целом. Это позволяет генерировать машинный код, который наиболее
      эффективно работает на данной платформе.


      **Встраивание методов**: Основываясь на собранной статистике выполнения,
      JVM может встраивать вызовы часто используемых методов непосредственно в
      вызывающий код, уменьшая накладные расходы на вызовы методов.


      **Оптимизация циклов**: Циклы в программе могут быть автоматически
      оптимизированы для улучшения производительности, например, путем
      укрупнения циклов или их развертки.


      **Удаление «мертвого» кода**: Неиспользуемые участки кода могут быть
      идентифицированы и исключены из конечного машинного кода.


      **Деоптимизация**: Если динамический контекст программы меняется и
      определенные оптимизации перестают быть актуальными, JVM может выполнить
      деоптимизацию и вернуться к менее оптимизированной версии кода.




      Динамическая компиляция и оптимизация предоставляют возможность
      адаптировать Java-приложения к конкретным условиям выполнения, что в
      конечном итоге позволяет улучшить производительность и эффективность
      работы программы на различных платформах.
  answers: []
mKqAk:
  comment:
    user:
      mail: alexbbtsk@gmail.com
      name: ALhoc27
    dateTime: '2024-10-06T15:16:54.359Z'
    content: >-
      Стандартная библиотека Java (API), также известная как Java API
      (Application Programming Interface), представляет собой набор
      предварительно скомпилированных классов и интерфейсов, предоставляемых
      вместе с Java Development Kit (JDK). Эта библиотека обеспечивает основные
      функциональные возможности, которые используются для разработки
      Java-приложений.


      Вот некоторые ключевые части стандартной библиотеки Java:




      **1\.java.lang:** Основные классы, которые включают в себя примитивные
      обёртки (например, **Integer**, **Character**), основные классы
      (**Object**, **String**, **System**), классы для работы с математикой
      (**Math**) и многие другие.


      **2\.java.util:** Коллекции (например, **ArrayList, HashSet, HashMap**),
      утилиты даты и времени (Date, Calendar), и другие утилиты.


      **3\.java.io:** Классы для ввода и вывода (I/O), такие как File\*\*,
      FileInputStream, FileOutputStream, BufferedReader, PrintWrite\*\*r и др.


      **4\.java.net:** Классы для работы с сетью, такие как URL,
      **URLConnection, Socket и ServerSocket.**


      **5\.java.math:** Классы для высокоточных математических операций
      (**BigInteger, BigDecimal**).


      **6\.java.nio:** Новый ввод-вывод (NIO) предоставляет более эффективные
      способы работы с вводом-выводом.


      **7\.java.sql:** Классы для взаимодействия с базами данных через **JDBC
      (Java Database Connectivity).**


      **8\.java.awt** и **javax.swing:** Библиотеки для создания графических
      пользовательских интерфейсов (GUI).


      **9\.java.security:** Классы для работы с безопасностью и криптографией.


      **10\.java.reflect:** Классы для работы с рефлексией, что позволяет
      исследовать и взаимодействовать с классами, методами и полями во время
      выполнения.


      **11\.java.concurrency:** Классы для многопоточной работы и параллельного
      программирования.


      **12\.java.text:** Классы для работы с текстом, форматированием и
      парсингом.




      Подчеркну, что это лишь верхушка айсберга. Java API состоит из тысяч
      классов и интерфейсов, и для полного понимания и использования его
      потребуется значительное время и опыт.
  answers: []
vMWDB:
  comment:
    user:
      mail: alexbbtsk@gmail.com
      name: ALhoc27
    dateTime: '2024-10-09T04:39:19.704Z'
    content: |-
      `// метод класса`

      `void bark() {`

      ```
       `System.out.println("Woof-Woof");` 
      ```

      `}`
  answers: []
WTJNG:
  comment:
    user:
      mail: alexbbtsk@gmail.com
      name: ALhoc27
    dateTime: '2024-10-09T06:23:21.212Z'
    content: >-
      Уровень пакета


      **Безопасность на уровне пакета (Package-Level Security)** в Java обычно
      относится к механизму, который ограничивает доступ к классам и интерфейсам
      в пакете.


      Это может быть реализовано с помощью модификаторов доступа, которые
      управляют тем, какие другие классы могут получить доступ к определенным
      членам класса или интерфейса.




      В Java пакеты являются способом группировки связанных классов и
      интерфейсов вместе. Пакеты помогают организовать код и предотвращают
      конфликты имен классов и интерфейсов.




      В Java существует четыре модификатора доступа: **public**, **protected**,
      **(default)** и **private**. Они играют ключевую роль в управлении
      доступом на уровне пакета.




      **\-** `public`**:** Классы, поля, методы и конструкторы, объявленные как
      public, доступны из любого другого класса.


      **\-** `protected`**:** Элементы, объявленные как protected, доступны всем
      классам в том же пакете и всем подклассам.


      **\-** `(default)`**:** Если модификатор доступа отсутствует, используется
      модификатор доступа по умолчанию, который позволяет доступ из того же
      пакета.


      **\-** `private`**:** Элементы, объявленные как private, доступны только
      внутри класса, в котором они объявлены.
  answers: []
s6AA0:
  comment:
    user:
      mail: alexbbtsk@gmail.com
      name: ALhoc27
    dateTime: '2024-10-09T06:23:50.603Z'
    content: >-
      Уровень доступа к методам классов\*\*:\*\*


      -  `public`: Методы с модификатором `public` могут быть вызваны из любого
      места.


      -  `protected`: Методы с модификатором `protected` могут быть вызваны
      внутри класса, внутри пакета и в подклассах.


      -  `private`: Методы с модификатором `private` могут быть вызваны только
      внутри класса.


      -  **Модификатор по умолчанию**: Методы без указания модификатора доступны
      только внутри пакета.




      **Модификаторы доступа стандартные** (что к классам, что к методам)
  answers: []
81Jq1:
  comment:
    user:
      mail: alexbbtsk@gmail.com
      name: ALhoc27
    dateTime: '2024-10-09T06:24:25.123Z'
    content: >-
      Модификаторы


      **Уровень класса (Class-Level Security):** Уровень доступа к классам и их
      членам определяется модификаторами доступа:




      -  `public`**:** Классы и их члены с модификатором **public** доступны из
      любого места.


      -  `protected`**:** Классы и их члены с модификатором **protected**
      доступны внутри пакета и для всех подклассов, даже если они находятся в
      других пакетах.


      -  `private`**:** Классы и их члены с модификатором private доступны
      только внутри класса.


      -  `Модификатор по умолчанию (default)`: Классы и их члены без указания
      модификатора доступны внутри пакета в котором находится класс. Не нужно
      писать явное ключевое слово; если модификатор не указан, то используется
      **default**.
  answers: []
ncJcf:
  comment:
    user:
      mail: alexbbtsk@gmail.com
      name: ALhoc27
    dateTime: '2024-10-09T06:31:33.407Z'
    content: >-
      Уровень приложения


      **«Уровень приложения» (Application-Level Security)** относится к
      безопасности, которая управляется и реализуется на уровне конкретного
      приложения, а не на более низких уровнях, таких как операционная система
      или язык программирования. Это означает, что безопасность на уровне
      приложения ориентирована на конкретные потребности и требования
      приложения, и может включать в себя следующие аспекты:




      ### **Аутентификация и авторизация:**


      Аутентификация проверяет идентификацию пользователей, в то время как
      авторизация определяет, какие ресурсы доступны аутентифицированным
      пользователям.


      ### **Управление сессиями:**


      Эффективное управление сессиями важно для обеспечения безопасности,
      включая генерацию безопасных идентификаторов сессии и их защиту от
      перехвата.


      ### **Шифрование данных:**


      Шифрование данных важно для защиты конфиденциальности и целостности данных
      во время их передачи и хранения.


      ### **Валидация ввода и обработка ошибок:**


      Валидация ввода помогает предотвратить внедрение вредоносного кода через
      формы ввода, а правильная обработка ошибок помогает обеспечить, что
      информация об ошибках не раскрывает чувствительные данные.


      ### **Безопасность API:**


      Безопасные методы аутентификации, контроль доступа и ограничение скорости
      важны для обеспечения безопасности API.


      ### **Тестирование на проникновение и проверка кода:**


      Регулярное тестирование на проникновение и проверка кода на наличие
      уязвимостей помогают идентифицировать и устранять потенциальные угрозы
      безопасности.


      ### **Обновления и патчи:**


      Быстрое применение обновлений и патчей безопасности важно для устранения
      известных уязвимостей.


      ### **Логирование и мониторинг:**


      Логирование и мониторинг позволяют отслеживать и анализировать действия в
      приложении, что помогает обнаруживать и реагировать на инциденты
      безопасности.


      Эти и другие меры помогают создавать более безопасные приложения, снижая
      риски связанные с угрозами безопасности на уровне приложения.
  answers: []
FG2G6:
  comment:
    user:
      mail: alexbbtsk@gmail.com
      name: ALhoc27
    dateTime: '2024-10-09T06:34:10.816Z'
    content: >-
      Уровень виртуальной машины


      **Безопасность на уровне виртуальной машины Java (JVM-Level Security)**
      имеет критическое значение, поскольку JVM является основой выполнения
      приложений Java. Вот некоторые аспекты безопасности на уровне JVM:




      ### **Класслоадеры (Class Loaders):**


      В JVM, класслоадеры играют важную роль в безопасности, обеспечивая
      загрузку классов из доверенных источников и предотвращая загрузку
      вредоносных классов.


      ### **Байт-код Верификатор (Bytecode Verifier):**


      Верификатор байт-кода проверяет, что загруженный байт-код соответствует
      спецификациям Java и не содержит потенциально вредоносных инструкций.


      ### **Безопасность песочницы (Sandbox Security):**


      JVM предоставляет «песочницу» для выполнения кода, что ограничивает доступ
      кода к системным ресурсам и предотвращает вредоносные действия.


      ### **Политика безопасности (Security Policy):**


      В JVM можно определить политику безопасности, которая управляет доступом к
      ресурсам, таким как файлы и сетевые соединения.


      ### **Менеджеры безопасности (Security Managers):**


      Менеджеры безопасности в JVM предоставляют возможность определения и
      применения политик безопасности на уровне приложения.


      ### **Хеширование и шифрование:**


      JVM предоставляет библиотеки и API для хеширования и шифрования данных,
      что помогает обеспечить конфиденциальность и целостность данных.


      ### **Цифровые подписи:**


      JVM поддерживает цифровые подписи, что позволяет верифицировать источник и
      целостность кода и данных.


      ### **Управление доступом (Access Control):**


      JVM имеет встроенные механизмы управления доступом, которые позволяют
      управлять правами доступа к ресурсам и операциям в системе.


      ### **Аудит и логирование:**


      JVM может быть настроена для аудита и логирования действий, что помогает в
      обнаружении и реагировании на инциденты безопасности.




      Реализация этих и других мер безопасности помогает обеспечивать безопасное
      выполнение приложений Java и защиту от различных видов угроз безопасности.
  answers: []
GOcqG:
  comment:
    user:
      mail: alexbbtsk@gmail.com
      name: ALhoc27
    dateTime: '2024-10-09T15:38:08.416Z'
    content: >-
      Сборщик мусора


      Garbage Collection (сборка мусора) в Java -- это автоматический процесс
      управления памятью, который освобождает память, занимаемую объектами, к
      которым нет больше ссылок. Он помогает избежать утечек памяти,
      автоматически удаляя ненужные объекты, что снижает нагрузку на
      разработчика по ручному управлению памятью.


      Основные моменты:


      1. **Автоматический процесс** -- Java сама управляет памятью, что упрощает
      разработку.


      2. **Работа в фоновом режиме** -- сборщик мусора периодически проверяет
      объекты и удаляет те, которые не используются.


      3. **Generational Garbage Collection** -- объекты делятся на поколения
      (Young, Old/tenured), и объекты из Young поколения быстрее проверяются и
      удаляются, чем из Old.


      Сборка мусора позволяет Java-программам работать более стабильно и
      эффективно.
  answers: []
wsrzm:
  comment:
    user:
      mail: alexbbtsk@gmail.com
      name: ALhoc27
    dateTime: '2024-10-09T15:39:54.919Z'
    content: >-
      Байт - код


      Байт-код Java -- это промежуточный код, в который компилируются
      Java-программы. Когда вы пишете программу на Java и компилируете её с
      помощью компилятора (`javac`), исходный код (.java) переводится в байт-код
      (.class). Этот байт-код затем выполняется виртуальной машиной Java (JVM).


      Основные характеристики байт-кода:


      1. **Платформонезависимый** -- байт-код одинаков для всех платформ. Это
      позволяет запускать одну и ту же Java-программу на разных устройствах и
      операционных системах, если на них установлена JVM.


      2. **Оптимизирован для выполнения в JVM** -- байт-код специально
      разработан для работы в виртуальной машине, что позволяет JVM
      интерпретировать его или компилировать в машинный код конкретной платформы
      (через JIT-компиляцию).


      3. **Не является машинным кодом** -- байт-код не может быть напрямую
      выполнен процессором компьютера, для этого нужна JVM.


      Пример простого байт-кода может выглядеть так (упрощённо):


      `aload_0`


      `invokespecial #1`


      `return`


      Здесь `aload_0` загружает ссылку на объект, а `invokespecial` вызывает
      конструктор или метод.
  answers: []
eovAn:
  comment:
    user:
      mail: alexbbtsk@gmail.com
      name: ALhoc27
    dateTime: '2024-10-09T15:55:43.008Z'
    content: >-
      JIT


      **JIT (Just-In-Time) -- компилятор**


      **JIT** -- это компонент JVM, который компилирует “на ходу“ байт-код в
      машинный код для повышения скорости выполнения программы (*Когда JIT
      замечает, что часть кода исполняется часто, он компилирует этот код в
      машинный, что бы в дальнейшем JVM может исполнять этот скомпилированный
      машинный код напрямую, избегая интерпретации байт-кода*)
  answers: []
hzzQt:
  comment:
    user:
      mail: alexbbtsk@gmail.com
      name: ALhoc27
    dateTime: '2024-10-09T16:04:51.950Z'
    content: >-
      Куча


      **Куча** (heap) в Java -- это область памяти, предназначенная для хранения
      объектов во время выполнения программы.


      #### Основное назначение кучи:


      Куча служит для хранения всех объектов и данных, созданных с помощью
      оператора `new`, и позволяет этим объектам жить до тех пор, пока на них
      существуют ссылки. Когда на объект больше нет ссылок, сборщик мусора
      автоматически освобождает его память.


      ### Какие объекты хранятся в куче:


      1. **Объекты классов:** Каждый раз, когда создаётся экземпляр класса
      (например, `new Object()`), объект выделяется в куче.


      2. **Массивы:** Все массивы в Java (будь то массивы объектов или
      примитивных типов) также выделяются в куче.


      3. **Объекты, созданные через лямбда-выражения и анонимные классы:** Такие
      объекты, как экземпляры лямбд и анонимных классов, тоже хранятся в куче.


      4. **Строки (если они создаются с помощью** `new`): Хотя строки могут
      храниться в пуле строк (постоянная область памяти), строки, созданные явно
      через `new String()`, хранятся в куче.


      #### Основные особенности кучи:


      1. **Динамическое выделение памяти:** Всякий раз, когда создаётся новый
      объект или массив, JVM выделяет для него память в куче. Память остаётся
      выделенной, пока объект используется.


      2. **Глобальная область:** Куча -- это общая область памяти, доступная для
      всех потоков программы. Это позволяет объектам существовать в течение
      длительного времени и использоваться в разных частях программы.


      3. **Сборка мусора:** Когда объекты больше не используются (например, на
      них больше нет ссылок), они становятся кандидатами для удаления. JVM
      использует сборщик мусора (Garbage Collector) для автоматического
      управления памятью в куче.


      #### Структура кучи:


      Java использует **генерационную сборку мусора**, и куча делится на
      несколько поколений:


      -  **Young Generation (Молодое поколение):** Объекты сначала создаются в
      этой области. Она часто проверяется сборщиком мусора.


      -  **Old Generation (Старое поколение):** Если объекты долго живут и не
      удаляются, они перемещаются в старшее поколение.


      -  **Permanent Generation (PermGen) / Metaspace:** Здесь хранятся
      метаданные классов и информация о самих классах.


      `String s = new String("Hello, World!"); // объект строки хранится в куче`


      `Person person = new Person(); // объект person хранится в куче`


      `int[] arr = new int[10]; // массив arr также хранится в куче`


      #### Важные моменты:


      -  **Куча больше, чем стек:** Куча используется для хранения объектов,
      которые могут существовать длительное время, в то время как стек ограничен
      короткоживущими локальными переменными.


      -  **Медленнее стека:** Поскольку куча управляется сборщиком мусора и
      требует выделения и освобождения памяти, доступ к объектам в куче может
      быть медленнее, чем доступ к данным в стеке.


      Куча -- это ключевой элемент управления памятью в Java, обеспечивающий
      автоматическое и эффективное выделение и освобождение памяти для объектов
      программы.
  answers: []
IrjTc:
  comment:
    user:
      mail: alexbbtsk@gmail.com
      name: ALhoc27
    dateTime: '2024-10-09T16:09:08.039Z'
    content: >-
      Сборка мусора


      **Сборка мусора (Garbage Collection, GC)** -- это процесс автоматического
      управления памятью в Java, который освобождает память, занятую объектами,
      которые больше не используются программой.


      ### Основные моменты:


      1. **Автоматический процесс:** GC работает в фоновом режиме и удаляет
      объекты, на которые больше нет ссылок, освобождая память для новых
      объектов.


      2. **Избегание утечек памяти:** Программистам не нужно вручную освобождать
      память, что снижает риск утечек памяти и ошибок.


      3. **Generational Garbage Collection:** Java делит память на поколения:

         -  **Молодое поколение (Young Generation):** Для новых объектов, которые собираются чаще.

         -  **Старое поколение (Old Generation):** Для долгоживущих объектов.

      4. **Типы сборщиков мусора:**

         -  **Serial GC:** Однопоточный, простой, используется в небольших приложениях.

         -  **Parallel GC:** Многопоточный, параллельно собирает мусор, повышая производительность.

         -  **G1 GC:** Сбалансирован между паузами и производительностью, рекомендуем для больших приложений.

      Сборка мусора помогает избежать ручного управления памятью, делая Java-код
      более безопасным и стабильным.
  answers: []
h7ONz:
  comment:
    user:
      mail: alexbbtsk@gmail.com
      name: ALhoc27
    dateTime: '2024-10-09T16:50:09.648Z'
    content: >-
      Методы доступа


      **Методы доступа:** Для управления доступом к закрытым полям используются
      специальные методы, называемые геттерами и сеттерами:


      -  **Геттеры (getters):** Методы, которые возвращают значения закрытых
      полей.


      -  **Сеттеры (setters):** Методы, которые позволяют изменять значения
      закрытых полей, часто с дополнительной логикой проверки.
  answers: []
yoH19:
  comment:
    user:
      mail: alexbbtsk@gmail.com
      name: ALhoc27
    dateTime: '2024-10-09T17:36:02.860Z'
    content: >-
      Перегрузка метода


      **Перегрузка метода** и **раннее связывание** (early binding) -- это
      концепции, связанные с полиморфизмом в Java. Давайте разберём их
      подробнее:


      #### Перегрузка метода (Method Overloading)


      Перегрузка метода происходит, когда в одном классе есть несколько методов
      с одинаковым именем, но с разными параметрами. Эти методы могут
      различаться по:


      -  Количеству параметров


      -  Типу параметров


      -  Порядку параметров


      Перегруженные методы позволяют одной функции выполнять различные задачи в
      зависимости от переданных ей аргументов.


      Пример перегрузки метода:


      `class Calculator {`


      `// Перегруженные методы с разными типами и количеством параметров`


      `  public int add(int a, int b) {`


      `    return a + b;`


      `  }`


      `  public double add(double a, double b) {`


      `    return a + b;`


      `  }`


      `}`


      В этом примере метод `add` перегружен.


      #### Раннее связывание (Early Binding)


      **Раннее связывание** означает, что вызов метода разрешается компилятором
      во время компиляции, а не во время выполнения программы. Это возможно,
      когда компилятор точно знает, какой метод нужно вызвать, основываясь на
      сигнатуре метода (его имени и типах параметров).


      #### Как это связано с перегрузкой метода:


      При **перегрузке методов** выбор нужного метода происходит на этапе
      компиляции. Когда компилятор видит вызов перегруженного метода, он
      определяет, какой из методов вызвать, основываясь на переданных
      аргументах. Этот процесс называется **ранним связыванием**.


      `Calculator calc = new Calculator();`


      // Раннее связывание: компилятор знает, что нужно вызвать метод **add(int,
      int)**


      `int result1 = calc.add(10, 20);`


      // Раннее связывание: компилятор знает, что нужно вызвать метод
      **add(double, double)**


      `double result2 = calc.add(10.5, 20.5);`
  answers: []
NhI5C:
  comment:
    user:
      mail: alexbbtsk@gmail.com
      name: ALhoc27
    dateTime: '2024-10-09T18:01:31.461Z'
    content: >-
      Переопределение методов


      **Переопределение метода (Method Overriding)** и **позднее связывание
      (Late Binding)** -- это ключевые концепции, связанные с полиморфизмом в
      объектно-ориентированном программировании. Давайте разберём их подробнее и
      объясним взаимосвязь.


      #### Переопределение метода (Method Overriding)


      Переопределение метода происходит, когда подкласс (класс-наследник)
      предоставляет свою реализацию метода, который уже объявлен в его
      суперклассе (родительском классе). Это позволяет подклассу изменять или
      расширять поведение метода, унаследованного от родительского класса.


      #### Основные условия для переопределения метода:


      -  Метод в подклассе должен иметь **такую же сигнатуру**, как и в
      суперклассе (имя, количество и типы параметров).


      -  Метод в суперклассе не должен быть помечен как `final` или `static`,
      так как такие методы нельзя переопределить.


      Пример переопределения метода `makeSound()`


      `class Animal {`


      `  void makeSound() {`


      `    System.out.println("Animal is...");`


      `  }`


      `}`


      `class Dog extends Animal {`


      `  @Override`


      `  void makeSound() {`


      `    System.out.println("Dog is...");`


      `  }`


      `}`


      В этом примере метод `makeSound()` переопределён в классе `Dog`, чтобы
      изменить поведение, унаследованное от класса `Animal`.


      #### Позднее связывание (Late Binding)


      **Позднее связывание** -- это процесс, при котором решение о том, какой
      метод вызывать, принимается во время выполнения программы, а не на этапе
      компиляции. Позднее связывание применяется при использовании полиморфизма,
      когда программа решает, какой метод (переопределённый или нет) вызвать,
      основываясь на реальном типе объекта в момент выполнения программы.


      #### Как это связано с переопределением метода:


      При **переопределении методов** выбор, какой именно метод вызывать (из
      суперкласса или подкласса), определяется на этапе выполнения программы.
      Это происходит потому, что метод, который будет вызван, зависит от
      фактического типа объекта, на который ссылается переменная, а не от типа
      переменной.


      #### Почему это важно:


      -  **Раннее связывание (Early Binding):** Метод выбирается на этапе
      компиляции на основе типа переменной. Используется при перегрузке методов.


      -  **Позднее связывание (Late Binding):** Метод выбирается на этапе
      выполнения программы на основе фактического типа объекта. Используется при
      переопределении методов и полиморфизме.


      #### Различие между ранним и поздним связыванием:


      -  **Раннее связывание** (например, перегрузка методов) происходит во
      время компиляции, потому что компилятор знает, какой метод вызвать на
      основе типа аргументов.


      -  **Позднее связывание** используется для методов, которые были
      переопределены в подклассах, и решение о вызове метода принимается на
      этапе выполнения программы, исходя из фактического типа объекта.
  answers: []
4V0An:
  comment:
    user:
      mail: alexbbtsk@gmail.com
      name: ALhoc27
    dateTime: '2024-10-09T18:19:23.085Z'
    content: >-
      В Java с версии 8 в интерфейсах не требуется явно указывать, что методы
      являются абстрактными. Все методы, объявленные в интерфейсе, по умолчанию
      считаются абстрактными, за исключением тех, которые имеют реализацию
      (методы по умолчанию и статические методы).
  answers: []
