jOiFy:
  comment:
    user:
      mail: alexbbtsk@gmail.com
      name: ALhoc27
    dateTime: '2024-10-22T10:59:50.756Z'
    content: >-
      Все что касается наследования могут спросить на собеседовании, но в
      практике этого использовать не надо.


      Да и если спрашивают про наследование, я бы задумался, стоит ли идти в
      компанию, где продолжают использовать этот механизм для расширения кода.


      Далее в разделе «Полиморфизм» будет наглядно показано, каким образом можно
      сделать код гибким без использования наследования.
  answers: []
RTSKW:
  comment:
    user:
      mail: alexbbtsk@gmail.com
      name: ALhoc27
    dateTime: '2024-10-22T11:04:47.672Z'
    content: >-
      # Инициализация локальных переменны**х**


      -  Локальные переменные (объявленные внутри методов или блоков) должны
      быть **явно инициализированы перед использованием**, иначе будет ошибка
      компиляции. *Локальные переменные можно **объявить(без инициализации)**,
      но до использования требуется **инициализировать**, иначе будет ошибка*


      -  Компилятор **не инициализирует локальные переменные** значениями по
      умолчанию (в отличие от полей класса).


      `public void exampleMethod() {`


      `int localVar; // Объявлена, но не инициализирована`


      `// System.out.println(localVar); // Ошибка: переменная не
      инициализирована`


      `localVar = 10; // Инициализация`


      `System.out.println(localVar); // Всё корректно`


      `}`


      ### **Когда происходит инициализация полей?**


      -  **Статические поля** -- инициализируются при **загрузке класса**.


      -  **Поля экземпляра** -- инициализируются **при создании объекта**.
  answers: []
LED6m:
  comment:
    user:
      mail: alexbbtsk@gmail.com
      name: ALhoc27
    dateTime: '2024-10-22T16:22:01.088Z'
    content: '# по умолчанию, без модификатора'
  answers: []
KfLSs:
  comment:
    user:
      mail: alexbbtsk@gmail.com
      name: ALhoc27
    dateTime: '2024-10-22T16:22:17.409Z'
    content: >-
      # Цель конструктора в абстрактном класс**е**


      -  **Абстрактный класс не может быть инстанцирован** напрямую, но он может
      содержать конструктор.


      -  Конструктор абстрактного класса вызывается **из подкласса** для
      инициализации общих полей и выполнения базовой логики.


      ## **Модификаторы конструктора в абстрактном классе**


      ### 1\. `protected` (часто используемый вариант)


      -  **Идеально для контроля доступа:** Конструктор доступен только для
      подклассов (внутри пакета или за его пределами, если они наследуются).


      -  **Пример использования:** Если абстрактный класс предназначен для
      наследования, но его логика не должна быть доступна для создания
      экземпляров в других местах напрямую.


      ### 2\. `public`


      -  Используется, если класс должен быть легко расширяем любыми другими
      классами (даже из других пакетов).


      -  Подходит для **базовых абстрактных классов**, которые могут быть
      использованы как часть библиотеки.


      ### 3\. **package-private** (по умолчанию, без модификатора)


      -  Конструктор будет доступен только классам внутри того же **пакета**.


      -  Уместно, если абстрактный класс и его наследники предполагаются для
      использования внутри пакета и не должны быть доступны извне.


      ### 4\. `private` (редко используется)


      -  **Возможен**, но используется очень редко.


      -  Применяется для **реализации шаблона проектирования Singleton или
      Factory**, когда создание экземпляров абстрактного класса ограничено самим
      классом.
  answers: []
U7Nkr:
  comment:
    user:
      mail: alexbbtsk@gmail.com
      name: ALhoc27
    dateTime: '2024-10-22T16:22:35.100Z'
    content: >-
      Модификатор - описание - применимост**ь**


      `public` - Неявно применяется ко всем методам - **Абстрактным**,
      **default**, **static**


      `default` - Позволяет задавать реализацию - Только для **нестатических
      методов**


      `static` - Статическая логика, привязанная кинтерфейсу - Не требует
      экземпляра


      `private` - Служебная логика для **default** и **static** - Невидим для
      классов
  answers: []
WtdPH:
  comment:
    user:
      mail: alexbbtsk@gmail.com
      name: ALhoc27
    dateTime: '2024-10-25T18:39:18.645Z'
    content: >-
      # Статические переменные класс**а**


      -  Объявляются с модификатором `static`.


      -  Принадлежат **классу в целом**, а не отдельному объекту.


      -  **Общие для всех объектов** -- если один объект изменит значение, это
      изменение будет видно всем.


      -  Доступ через **имя класса** или объект (но предпочтительно использовать
      имя класса).




      # Особенности и правила static переменных:


      1. **Инициализируются** при загрузке класса.


      2. **Общие для всех экземпляров класса.**


      3. **Доступны через имя класса** без создания объекта.


      4. **Не освобождаются до завершения программы**, если класс остается
      загруженным.
  answers: []
Rou5M:
  comment:
    user:
      mail: alexbbtsk@gmail.com
      name: ALhoc27
    dateTime: '2024-10-25T18:44:49.406Z'
    content: >-
      Внутри метода переменные


      Внутри метода переменные (**Локальная переменные**) - не имеет
      модификаторов доступа, потому что доступны только в пределах метода.


      Объявляются и используются **только внутри метода или блока**.
  answers: []
hIkBb:
  comment:
    user:
      mail: alexbbtsk@gmail.com
      name: ALhoc27
    dateTime: '2024-10-25T18:45:23.369Z'
    content: >-
      Член класса, поле класса


      1. Объявляются **внутри класса, но вне методов**.


      2. Уникальны для каждого объекта -- каждый экземпляр имеет свою копию
      переменной.


      3. Доступ через `this` для различения полей и параметров.
  answers: []
f90Mr:
  comment:
    user:
      mail: alexbbtsk@gmail.com
      name: ALhoc27
    dateTime: '2024-10-26T14:43:04.906Z'
    content: >-
      Подробнее


      **−** `public` **(публичный):**


      Классы, методы, поля, конструкторы, помеченные модификатором `public` ,
      **доступны из любого места** , так и из других классов и пакетов.


      **−** `private` **(приватный):**


      Члены класса, помеченные модификатором `private` , **видны только внутри
      того же класса** . Они не доступны извне класса, включая подклассы.


      **−** `protected` **(защищенный):**


      `protected` - это также модификатор доступа, что и `default`, но с более
      широким уровень доступа.\

      Члены класса, помеченные модификатором `protected` , **видны классе, в
      внутри пакета, а также в подклассах** (даже если они находятся в другом
      пакете)


      **−** `default` **(по умолчанию, package-private)**


      Если член класса не имеет явного модификатора доступа (т.е., не помечен
      как `public` , `private` или `protected`, то он **считается доступным
      только внутри своего собственного пакета.**
  answers: []
NLUSb:
  comment:
    user:
      mail: alexbbtsk@gmail.com
      name: ALhoc27
    dateTime: '2024-10-26T15:44:10.859Z'
    content: >-
      # Раннее связывание (Early Binding) в Jav**a**


      **Раннее связывание** -- это процесс, при котором вызов метода или
      обращение к полю связывается с соответствующим кодом **во время
      компиляции**, а не выполнения. Оно также известно как **статическое
      связывание**.


      ### **Когда используется раннее связывание?**


      Раннее связывание происходит, когда:


      1. **Метод или переменная являются** `static`.


      2. **Метод или переменная являются** `final` (метод не может быть
      переопределён).


      3. Метод является **приватным** (`private`), поскольку он недоступен для
      переопределения.


      4. Вызывается **конструктор**.


      5. Поле класса (переменная) также всегда связано с классом **на этапе
      компиляции**.




      ### **Преимущества и недостатки раннего связывания**


      **Преимущества:**


      -  **Быстрее** во время выполнения, так как компилятор уже знает, какой
      код должен быть выполнен.


      -  Избегает ошибок, связанных с поздним связыванием (например, если метод
      не найден при наследовании).


      **Недостатки:**


      -  **Меньшая гибкость**, так как многие решения принимаются на этапе
      компиляции.


      -  Не поддерживает **полиморфизм** -- если метод можно переопределить,
      использование раннего связывания ограничит возможность вызова версий
      подклассов.


      ### **Раннее связывание vs. Позднее связывание**


      -  **Раннее связывание**: Связь метода/поля происходит на этапе
      компиляции.


      -  **Позднее связывание (Late Binding)**: Связывание происходит во время
      выполнения, позволяя использовать **полиморфизм**.
  answers: []
'04E06':
  comment:
    user:
      mail: alexbbtsk@gmail.com
      name: ALhoc27
    dateTime: '2024-10-26T16:08:00.386Z'
    content: >-
      final переменные класса


      (*Это переменные, которые являются членами класса. Как только для
      **final** поля класса присвоено значение, оно не может быть изменено.
      **Эти переменные должны быть инициализированы либо в момент их объявления,
      либо в конструкторе класса**. Если **final** поле не инициализировано
      напрямую при объявлении, то оно должно быть инициализировано в каждом
      конструкторе класса. Если класс имеет несколько конструкторов, каждый из
      них должен инициализировать **final** поле, чтобы гарантировать, что перед
      использованием поле будет иметь значение.*)
  answers: []
hTL0w:
  comment:
    user:
      mail: alexbbtsk@gmail.com
      name: ALhoc27
    dateTime: '2024-10-26T16:08:53.868Z'
    content: Обычные переменные экземпляра и статические переменны**е**
  answers: []
